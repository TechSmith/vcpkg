diff --git a/glib/gspawn.c b/glib/gspawn.c
index 581729733..e132ca40a 100644
--- a/glib/gspawn.c
+++ b/glib/gspawn.c
@@ -70,11 +70,6 @@
 #include "glibintl.h"
 #include "glib-unix.h"
 
-#ifdef __APPLE__
-#include <libproc.h>
-#include <sys/proc_info.h>
-#endif
-
 #define INHERITS_OR_NULL_STDIN  (G_SPAWN_STDIN_FROM_DEV_NULL | G_SPAWN_CHILD_INHERITS_STDIN)
 #define INHERITS_OR_NULL_STDOUT (G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_CHILD_INHERITS_STDOUT)
 #define INHERITS_OR_NULL_STDERR (G_SPAWN_STDERR_TO_DEV_NULL | G_SPAWN_CHILD_INHERITS_STDERR)
@@ -1544,36 +1539,6 @@ safe_fdwalk_with_invalid_fds (int (*cb)(void *data, int fd), void *data)
   if (open_max < 0)
     open_max = 4096;
 
-#if defined(__APPLE__)
-  /* proc_pidinfo isn't documented as async-signal-safe but looking at the implementation
-   * in the darwin tree here:
-   *
-   * https://opensource.apple.com/source/Libc/Libc-498/darwin/libproc.c.auto.html
-   *
-   * It's just a thin wrapper around a syscall, so it's probably okay.
-   */
-  {
-    char buffer[4096 * PROC_PIDLISTFD_SIZE];
-    ssize_t buffer_size;
-
-    buffer_size = proc_pidinfo (getpid (), PROC_PIDLISTFDS, 0, buffer, sizeof (buffer));
-
-    if (buffer_size > 0 &&
-        sizeof (buffer) >= (size_t) buffer_size &&
-        (buffer_size % PROC_PIDLISTFD_SIZE) == 0)
-      {
-        const struct proc_fdinfo *fd_info = (const struct proc_fdinfo *) buffer;
-        size_t number_of_fds = (size_t) buffer_size / PROC_PIDLISTFD_SIZE;
-
-        for (size_t i = 0; i < number_of_fds; i++)
-          if ((res = cb (data, fd_info[i].proc_fd)) != 0)
-            break;
-
-        return res;
-      }
-  }
-#endif
-
   for (fd = 0; fd < open_max; fd++)
       if ((res = cb (data, fd)) != 0)
           break;
